Java基础
    、String为什么是final的
    、HashMap和Hashtable区别
    、HashMap源码, 实现原理, 底层结构
    、ConcurrentHashMap源码, 实现原理(jdk1.7 jdk1.8), 底层结构
    、ArrayList和LinkedList区别
    、反射中, Class.forName和classloader区别
    、Java8有哪些新特性
    、Java内存泄漏问题如何定位解决
    、接口和抽象类的区别(jdk1.8)
    、Java IO 常见类, 分类
    、BIO、NIO、AIO
    、同步、异步、阻塞、非阻塞IO的区别
    、实现序列化、反序列化的方式
    、什么是反射、反射的优缺点
    、面向对象的理解
    、面向对象的三大特性
    、重写和重载的区别(知乎)
    、类之间的关系(知乎)
    、几种内部类区别
    、接口和抽象类的区别, 使用场景
    、Java中的值传递与引用传递
    、Java中的深拷贝与浅拷贝
    、Class类的作用
    、Java泛型、泛型擦除
    、Java8新特性
    、Java异常
    、Iterator和ListIterator
    、动态代理、静态代理 及二者实现方式

多线程
    、什么是线程池
    、线程池的submit和execute方法的区别
    、run方法和start方法区别
    、线程池是什么, 有什么好处, 常用线程池、及使用场景 ThreadPoolExecutor, ScheduledThreadPoolExecutor、ForkJoinPool
    、创建线程池的参数(ThreadPoolExecutor)
    、如何关闭线程池
    、线程池的选择策略
    、阻塞队列有哪些
    、线程池之间的处理流程
    、多线程间通信方式及区别
    、synchronized锁的对象、多个锁方法间的相互调用
    、可重入锁、ReentrantLock、synchronized、LockSupport、CountdownLatch、ReadWriteLock区别
    、ReentrantLock的公平性与非公平性
    、ReentrantLock如何实现可重入性
    、什么是读写锁
    、volatile如何实现多线程安全、多线程可见性、防止指令重排序、为什么代码会重排序、volatile内存模型
    、AtomicInteger、原子类如何实现
    、wait、sleep、join区别 notify、notifyAll区别
    、进程和线程区别
    、JUC、常见JUC类及使用。ThreadPool、BlockingQueue深入考察
    、什么是CAS
    、CyclicBarrier是什么
    、Semaphore是什么
    、Exchanger是什么
    、JMM是什么、有什么作用
    、as-if-serial、happens-before是什么, 有什么区别
    、原子性、可见性、有序性分别是什么
    、final可以保证可见性么
    、锁优化策略
    、如何实现一个多线程安全的程序
    、死锁、四个必要条件、如何解决死锁、如何排查死锁、如何排查使用CPU时间最长的线程
    、什么是多线程的上下文切换
    、什么事线程组, 为什么不推荐使用
    、Java中线程的调度算法
    、Java中的Executor和Executors区别
    、实现线程的方式
    、Runnable、Callable、Future、FutureTask区别
    、什么是thread dump
    、常用集合的并发安全类ConcurrentHashMap、CopyOnWritArrayList
    、interrupted和isInterrupted区别
    、什么是守护线程、如何保证main线程最后结束
    、线程状态流转过程
    、线程池创建的几种方式
    、Java中的CAS
    、什么事AQS、AQS支持同步的方式
    、自旋、自旋锁、自适应自旋锁
    、什么是锁消除
    、什么是锁粗化
    、偏向锁、轻量级锁、重量级锁分别是什么, 有什么区别
    、Lock和Synchronized区别
    、什么是AQS, 两种模式是什么, 独占式获取和释放锁的原理, 共享锁获取和释放锁的原理
    、线程的生命周期
    、线程的创建方式
    、ThreadLocal
    、多线程的内存模型、执行过程
    、并发与并行的区别
高并发与性能调优
    、如何设计一个高并发的系统(如秒杀应用)、如何支撑大量的请求
    、负载均衡 实现负载均衡的方式及区别
    、集群如何实现同步回话状态
    、大量数据库请求如何处理
    、当系统出现高并发时, 如何解决服务请相应不及时的问题
    、如何定位排查性能瓶颈原因
    、缓存、为什么使用
    、流量在某一时刻暴涨、然后又暴跌如何应对
    、如何实现分布式锁
    、分布式中Session如何实现
    、如何解决分布式事务
Linux
    、常用的Linux命令
网络
    、http请求、无状态通信如何保持回话、请求方式有哪些、可以自定义新的请求方式么
    、HTTP响应码
    、forward和redirect
    、TCP如何连接(为什么需要三次握手和四次挥手)、与http、UDP的区别
    、OSI七层模型
    、访问一个网站如www.baidu.com过程
    、HTTP和HTTPS区别
    、HTTPS如何实现安全性
    、POST和GET的区别
    、集群时如何共享登录状态
    、XSS、CSRF、SQL注入
    、浏览器缓存策略
    、Ajax如何解决跨域问题
    、DNS 如何实现域名解析
    、如何保持长链接
    、JSONP是什么, 实现原理
操作系统
    、LRU算法
    、数据预读
    、局部性原理
    、CPU调度逻辑
    、磁盘读取逻辑
    、kill杀不掉进程的原因
    、缓存原理
JVM
    、Java内存模型(jdk8、jdk7)
    、垃圾回收算法、新生代, 老生代分别怎么实现的, 有哪些垃圾回收算法
    、JVM中7个区域, 每个区域造成内存溢出的原因及解决方案
    、类加载机制、加载顺序、双亲委派、如何自定义classloader, 类初始化过程、有哪些类加载器, 如何判断两个类是否相同、父类与子类初始化顺序
    、运行时常量区, 运行时常量区溢出的原因及解决方式, 常量池、字符串常量池
    、JVM如何分配内存、new对象如何不分配在对上而分配到栈上
    、如何回收过期对象(垃圾对象)、判断依据是什么
    、内存溢出如何排查
    、应用响应突然变得很慢如何排查
    、运行时数据区是什么
    、程序计数器是什么
    、Java虚拟机栈是什么
    、本地方法栈是什么
    、堆得作用
    、方法区的作用, 方法区溢出的原因及解决方式
    、直接内存是什么
    、内存溢出和内存泄漏是什么, 有什么区别
    、堆溢出的原因、栈溢出的原因
    、创建对象及加载过程、对象内存的分配方式、对象分配内存是否线程安全
    、对象的内存布局
    、对象的访问方式
    、Java中的引用
    、内存分配及回收策略
    、排查故障的工具
    、Java程序运行过程
Spring
    、SpringMVC原理、处理流程、常用注解、有哪些组件
    、SpringMVC DispatcherServlet工作流程
    、Spring中FactoryBean、BeanFactory和ApplicationContext区别
    、Spring注入的几种方式及区别、什么是循环注入
    、Spring的IOC、AOP原理, 如何实现、类内部之间调用能否处罚AOP
    、IOC容器初始化过程
    、依赖注入的实现方式、相关注解、执行过程
    、Bean的生命周期、作用范围、Spring中单例、原型模式如何设置, 其他scope有什么作用
    、Spring事务管理、几种事务区别
    、如何加载bean、如何实现bean的自动装配
    、
MyBatis
    、hibernate和MyBatis
    、MyBatis连接池
    、MyBatis执行逻辑
    、${} 与 #{} 区别
    、如何实现分页、分页插件的实现原理、MyBatis分页方式、与Oracle分页方式的区别
    、MyBatis缓存、一级、二级缓存
    、MyBatis优缺点
    、MyBatis延时加载、原理、执行过程
    、如何自定义插件
Memcached
    、是什么, 有什么用, 如何使用
    、Memcached服务分布式集群如何实现
    、Memcached服务特点及工作原理
    、Memcached与Redis区别
Redis
    、是什么, 有什么用, 适用场景
    、Redis数据类型
    、一个字符串类型的值能存储最大容量是多少
    、Redis持久化机制及区别
    、Redis过期键的删除策略
    、Redis回收策略(淘汰策略)
    、Redis集群、集群的原理、导致集群不可用的原因及如何解决、如何解决集群中读写丢失
    、Redis哈希槽
    、Redis事务
    、Redis常用命令
    、大量key同时过期
    、异步队列
    、redis支持的Java客户端有哪些
    、怎么保证缓存与数据库数据一致性
    、如何实现分布式锁, 分布式锁的优缺点
MySQL
    、SQL执行过程 MySQL逻辑架构
    、MySQL几种存储引擎及区别
    、索引、分类、实现方式、使用方式、如何优化
    、如何分库分表 何时分库分表、如何分库分表、分库分表带来复杂性如何解决、为什么数据量大的时候需要分库分表
    (如自增主键如何在多表实现、多表如何join查询、如何保证分布式事务、如何分页查询)
    、主从复制、读写分离如何实现 读写分离的执行过程
    、MySQL日志 分类、作用、区别
    、索引的数据结构 为什么使用B+树
    、MySQL锁 分类、实现
    、数据库事务、事务的4个特性及如何实现、事务隔离级别、数据不一致性
    、MVCC多版本并发控制
    、间隙锁
    、行锁、表锁、页锁
    、乐观锁、悲观锁
    、MySQL调优
    、char(10) varchar(10) int(10)的区别
    、数据库范式
    、主键和候选键区别
    、哈希索引、自适应Hash索引
    、什么是空间索引
    、什么是全文索引
    、join连接查询执行过程、原理 与哈希连接的区别
    、如何确定SQL是慢查询SQL (SHOW PROFILE、EXPLAIN、TRACE)
    、EXPLAIN执行计划有哪些字段、分别含义是什么
    、唯一索引能否插入null, 如何处理
    、MySQL如何判断字段是否为null
    、如何定位数据库死锁、如何解决
    、数据库内置几种时间类型的区别
    、数据库优化策略、使用原则
    、B树与B+树及对应索引的实现、使用
    、聚簇索引、非聚簇索引
    、覆盖索引、回表
    、主键索引树与非主键索引树的区别 (B树、B+树)
    、前缀索引
    、最左匹配原则
    、索引失败 原因及解决方式
    、如何优化关联查询
    、重启会导致自增主键变化么
设计模式
    、单例模式 实现方式及区别、那些可以并发安全
    、工厂模式
    、装饰者模式
    、观察者模式
    、项目中使用了哪些设计模式
    、设计模式有哪些原则
    、设计模式分类、常见的设计模式有哪些
    、简单工厂、工厂方法、抽象工厂区别
    、单例模式几种实现方式、及区别
    、代理模式、装饰器模式、适配器模式 区别
    、策略模式
    、模板方法模式
    、观察者模式
算法
    、排序算法
    、如何计算时间复杂度、空间复杂度
    、获取随机数, 生成1-1000W之间的所有数据, 考虑高效性, 如何结局冲突
    、给定一个函数, 返回0和1, 概率为p和1-p, 实现一个函数, 使得返回01概率是一样的
    、两个长度为n的有序数组, 计算中位数
    、一个有序数组, 其中一个数变为-1, 如何找到这个树, 至少用三种方法
    、字符串反转
    、两个有序数组的合并排序
    、一个数组的倒序
    、计算一个正整数的平方根
    、二叉树的遍历算法(递归、非递归)
    、DFS、BFS
    、逆波兰计算器
    、哈夫曼算法、哈夫曼编码
数据结构
    、List、Map、Set区别
    、红黑树、AVL树 区别
    、B树与B+树
微服务
    、什么是微服务、微服务有什么优势
    、单片、SOA和微服务的区别
    、什么是领域驱动设计
    、什么是REST、RESTFul
    、什么是Spring引导执行器
SpringBoot
    、什么是SpringBoot
    、什么是JavaConfig
    、如何重新加载SpringBoot上的更改, 而无需重新启动服务
    、什么是监视器
    、什么是YAML
    、CSRF攻击
    、什么是JPA, 和hibernate和MyBatis区别
    、什么是断路器
SpringCloud
    、什么是服务注册与发现
    、什么是Hystrix, 如何实现容错
    、什么是Hystrix断路器
    、如何搭建微服务集群, 如何负载微服务接口
    、什么是Netflix Feign
Nginx
    、原理、如何实现负载均衡
    、负载均衡算法
RabbitMQ
    、什么是RabbitMQ、使用场景
    、如何确保消息正确地发送到RabbitMQ, 如何保证消息接收方消费了消息
    、如何确保消息不丢失、如何避免消息重复投递、如何避免消息重复消费
    、消息基于什么传输
    、消息如何分发、消息如何路由
    、搭建RabbitMQ集群, 集群有什么作用
    、节点类型有哪些、每个节点是其他节点的完整拷贝么
    、集群中唯一一个磁盘节点崩溃了会发生什么情况
    、对集群节点停止顺序要求
    、RabbitMQ和kafka的区别, 各自适用场景
    、有哪些重要角色
    、vhost是什么
    、要保证消息持久化成功的条件
    、几种广播方式
    、如何实现延时消息队列
kafka
    、什么是kafka
    、可以脱离zookeeper单独使用么
    、数据保留策略
    、数据暴涨如何处理
    、为什么运行效率变慢, 原因及解决方式
    、如何获取topic主题的列表
    、生产者和消费者的命令行是什么
    、consumer是推还是拉
    、kafka维护消费状态跟踪的方法
    、什么是主从同步
    、Zookeeper对kafka的作用
    、数据传输的事务
    、如何判断结点是否存活
    、kafka的ack机制
    、活锁问题
    、kafka分布式集群中, 如何保证消息的消费顺序
    、kafka的高可用机制是什么
    、kafka如何减少数据丢失、如何解决重复消费
Zookeeper
    、是什么
    、有哪些功能
    、有几种部署方式
    、如何保证主从节点的状态同步
    、集群中问什么要有主节点
    、集群中一台节点宕机了, 还能使用么
    、通知机制
kubernetes(K8S)
工作经验
    、Maven中如何排查包冲突
    、IDEA如何合并代码
    、程序开发的流程
    、什么样的代码是比较好的代码


    你终将遇到的高质量Java面试题