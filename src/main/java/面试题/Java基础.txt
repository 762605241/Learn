1、JVM、JRE、JDK区别
    1、JVM是Java虚拟机, 用于运行Java程序的地方。JVM是Java实现跨平台的基础, 不同操作系统的JVM实现不同。Java通过编译将Java文件转换成字节码文件,
    字节码文件可以在任何Java虚拟机上执行,并且可以保证不同操作系统中, 最后的执行结果相同。这既是一次编译, 到处运行。
    2、JRE是Java运行时环境, 用于搭建Java程序运行所需的环境, 包括JVM、核心类库等。项目部署时只需要安装JRE, 即可完成Java程序在服务器中的运行。
    3、JDK是Java开发工具包, 是开发人员开发、调试、运行Java程序的, 包括JRE、编译工具javac、打包工具jar等。
    JVM、JRE、JDK区别.png
2、Java中数据类型
    1、基础类型
        布尔型 boolean
        字符型 char
        整型 byte、short、int、long
        浮点型 float、double
    2、引用型
        类
        接口
        数组
    Java基本数据类型图.png
3、访问修饰符public、protected、默认(不写)、private
    1、Java中实现封装的体现之一。通过不同的访问修饰符来控制外部对象是否可以访问本类中成员变量及方法。
    2、区别
        private: 在同一个类中可见。
        默认(不写): 在同一个包内可见。其他包内的子类也不可见。
        protected: 在同一个包内可见。其他包内的子类也可见。
        public: 整个工程下都可见。
    访问修饰符.png
4、面向对象
    1、面向对象与面向过程区别
        1、面向过程:
            优点: 性能比面向对象高。因为面向对象中类间调用需要先实例化对象, 开销较大, 耗费更多资源。
            缺点: 没有面向对象易维护、易复用、易扩展
        2、面向对象:
            优点: 易维护、易复用、易扩展。由于面向对象具有封装、继承、多态。可以设计出耦合度更低的系统, 使系统更加灵活、更容易维护。
            缺点: 性能叫面向过程低。
            面向对象的底层还是面向过程, 一个方法调用类一个方法, 按步骤依次执行。
5、面向对象的特征
    1、抽象：
        抽象是将一类对象的共同特征抽取出来构建成类的过程。包括数据抽象和行为抽象两个方面。
        隐藏对象属性和方法的实现细节, 仅对外提供公共的访问方式。将变化隔离, 提高复用性和安全性。
    2、封装:
        封装是把一个对象的属性、方法私有化, 同时提供一个供外部对象访问入口, 可以只提供需要暴露出的内容, 其余内容外部不可见。具体实现外部不需要关系。
    3、继承:
        继承是指以现有的类为基础, 建立新类的过程。新类可以根据自身要求增加新的属性和方法, 也可也直接使用父类的方法。Java中类只允许单继承, 需要多继承可以使用接口实现。
        子类可以拥有父类非private属性和方法。
        子类可以增加属性和方法, 扩展父类。
        子类可以重写父类方法, 扩展父类。
    4、多态:
        多态是指程序中定义的引用变量所指向的具体类型和通过该变量触发的方法调用在编译时并不确定, 而是在运行期间才确定。
        Java中多态的表现形式有两种: 1、子类继承父类, 重写父类的方法; 2、同一个类之间, 存在重载方法。
        1、实现多态的三个必要条件
            继承、重写、向上转型
6、面向对象的五大基本原则
    1、单一职责原则: 类的功能要单一。只实现具体某一个功能, 不要将多个功能放在一个类中实现。
    2、开闭原则: 对扩展开发, 对修改封闭。
    3、里氏替换原则: 子类可以替换父类出现过的任何地方。子类 is a 父类。
    4、依赖倒置原则: 依赖抽象, 而不是以来具体实现。方便扩展, 提高复用性。
    5、接口隔离原则: 将接口进行拆分, 将多个功能拆分到多个接口中。每个接口实现一个功能。类似于单一职责原则。
7、接口与抽象类
    1、抽象类是定义子类共有通用的属性和方法, 表示子类 is a 父类。接口是定义子类具有哪些行为的, 表示子类 as a 父类。
    2、相同点:
        1、接口和抽象类本身不能实例化, 需要通过继承, 以子类来实例化使用。
        2、用于子类继承或实现。
        3、都包含抽象方法、子类继承或实现时, 必须重写。
    3、不同点:
        1、声明方式不同, 抽象类使用abstract, 接口使用interface。
        2、子类继承或实现的方式不同, 抽象类通过extends继承, 并且只能实现一个抽象类, 接口通过implements实现, 允许子类实现多个接口。
        3、抽象类可以有构造器, 接口不能有。
        4、抽象类中可以使用不同的访问修饰符, 而抽象类中属性都是public static final, 抽象方法都是public。
        5、Java8中接口, 引用了默认方法和静态方法。默认方法并不要求子类实现。
    4、如何选择
        1、行为模型应该优先使用接口而不是抽象类。
        2、当需要定义子类的通用行为时, 使用抽象类。
8、BIO、NIO、AIO
    1、BIO: Block IO 同步阻塞IO模式。数据的读取和写入必须阻塞在同一个线程内等待其完成。在活动连接数不是很高时(小于单机1000)的情况下, 可以让每个连接
    专注于自己的IO并且实现简单。也不用考虑系统的过载、限流等问题。可以使用线程池来缓存一些暂时处理不了的任务。但是当任务达到十万百万时, 传统的IO模式效率就非常低了。
    2、NIO: Non IO NIO是一种同步非阻塞IO模式。在jdk1.4中引入NIO。提供了Channel、Selector、Buffer等抽象。NIO中的N可以理解为Non-Blocking, 不单纯是new。
    它支持面向缓冲的, 基于通道的IO操作方式。NIO提供了与传统BIO模式中Socket、ServerSocket相对应的SocketChannel、ServerSocketChannel两种不同的套接字通道实现。
    两种通道都支持阻塞和非阻塞模式。阻塞模式就和BIO模式一样, 使用简单, 但性能和可靠性都不好。对于低负载、低并发的应用程序, 可以使用同步阻塞方式开发, 提高开发效率和维护性。
    对于高负载、高并发(网络)应用程序, 使用同步非阻塞模式来实现, 达到更好的并发性能。
    3、AIO: Asynchronous IO 在Java7中引入。它是异步非阻塞模式IO。基于事件和回调机制实现的。也就是调用方操作之后会立即返回, 线程不会阻塞, 当处理方处理完成后, 操作系统会
    通知相应线程进行后续操作。AIO是异步IO的缩写。虽然NIO在网络操作中, 提供了非阻塞的方法。但是NIO的行为还是同步的。对于NIO来说, 我们的业务线程是在IO操作准备好时(可以进行IO操作)
    得到通知, 接着就由这个线程自行进行IO操作, IO操作本身是同步的。
9、反射
    1、Java反射机制就是在运行状态中, 对于任意一个类, 都能获取其所有属性方法。对于任意一个对象, 都能调用其任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能称为
    Java语言的反射机制。
    2、优缺点
        优点: 运行期类型判断, 动态加载类, 提高代码的灵活度, 方便扩展。
        缺点: 性能问题, 需要通知JVM进行一系列的解释操作, 性能要比直接调用Java代码低。破获代码封装性。
    3、应用场景
        1、反射是框架设计的灵魂
            JDBC连接数据库时, 使用Class.forName()加载数据库驱动。
            Spring装载Bean过程。
    4、实现反射的方式
        1、通过对象实例实现: Class clazz = object.getClass();
        2、通过类路径实现: Class clazz = Class.forName();
        3、通过类名实现: Class clazz = Object.class;
10、String真的是不可变的么?
    一般来说是的。一般开发中, 对String类型的变量做修改时, 都是将变量的引用改为其他地址。
    但是可以通过反射来修改String类中的char数组的值来实现改变String。
11、HashMap使用String做key的好处?
    HashMap保存数据时, 需要对key进行hash()处理, 获取key的散列码, 来确定其对应的存储位置。因为String是不可变的, 相同的字符串对应的散列码也不会改变。
    相同的字符串不需要重新计算散列值, 会被缓存下来, 方便下次使用, 所以会较其他对象更快。
12、Integer a = 127 和 Integer b = 128
    当整型在-128到127之间时, 不会创建其包装类, 会从常量池中获取。所以int a = 127 == Integer a = 127。当大于这个范围时, 会创建对应的包装类。此时==返回false。
    这个范围可以被修改-128到更大。
13、集合容器概念