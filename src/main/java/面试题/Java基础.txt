1、JVM、JRE、JDK区别
    1、JVM是Java虚拟机, 用于运行Java程序的地方。JVM是Java实现跨平台的基础, 不同操作系统的JVM实现不同。Java通过编译将Java文件转换成字节码文件,
    字节码文件可以在任何Java虚拟机上执行,并且可以保证不同操作系统中, 最后的执行结果相同。这既是一次编译, 到处运行。
    2、JRE是Java运行时环境, 用于搭建Java程序运行所需的环境, 包括JVM、核心类库等。项目部署时只需要安装JRE, 即可完成Java程序在服务器中的运行。
    3、JDK是Java开发工具包, 是开发人员开发、调试、运行Java程序的, 包括JRE、编译工具javac、打包工具jar等。
    JVM、JRE、JDK区别.png
2、Java中数据类型
    1、基础类型
        布尔型 boolean
        字符型 char
        整型 byte、short、int、long
        浮点型 float、double
    2、引用型
        类
        接口
        数组
    Java基本数据类型图.png
3、访问修饰符public、protected、默认(不写)、private
    1、Java中实现封装的体现之一。通过不同的访问修饰符来控制外部对象是否可以访问本类中成员变量及方法。
    2、区别
        private: 在同一个类中可见。
        默认(不写): 在同一个包内可见。其他包内的子类也不可见。
        protected: 在同一个包内可见。其他包内的子类也可见。
        public: 整个工程下都可见。
    访问修饰符.png
4、面向对象
    1、面向对象与面向过程区别
        1、面向过程:
            优点: 性能比面向对象高。因为面向对象中类间调用需要先实例化对象, 开销较大, 耗费更多资源。
            缺点: 没有面向对象易维护、易复用、易扩展
        2、面向对象:
            优点: 易维护、易复用、易扩展。由于面向对象具有封装、继承、多态。可以设计出耦合度更低的系统, 使系统更加灵活、更容易维护。
            缺点: 性能叫面向过程低。
            面向对象的底层还是面向过程, 一个方法调用类一个方法, 按步骤依次执行。
5、面向对象的特征
    1、抽象：
        抽象是将一类对象的共同特征抽取出来构建成类的过程。包括数据抽象和行为抽象两个方面。
        隐藏对象属性和方法的实现细节, 仅对外提供公共的访问方式。将变化隔离, 提高复用性和安全性。
    2、封装:
        封装是把一个对象的属性、方法私有化, 同时提供一个供外部对象访问入口, 可以只提供需要暴露出的内容, 其余内容外部不可见。具体实现外部不需要关系。
    3、继承:
        继承是指以现有的类为基础, 建立新类的过程。新类可以根据自身要求增加新的属性和方法, 也可也直接使用父类的方法。Java中类只允许单继承, 需要多继承可以使用接口实现。
        子类可以拥有父类非private属性和方法。
        子类可以增加属性和方法, 扩展父类。
        子类可以重写父类方法, 扩展父类。
    4、多态:
        多态是指程序中定义的引用变量所指向的具体类型和通过该变量触发的方法调用在编译时并不确定, 而是在运行期间才确定。
        Java中多态的表现形式有两种: 1、子类继承父类, 重写父类的方法; 2、同一个类之间, 存在重载方法。
        1、实现多态的三个必要条件
            继承、重写、向上转型
6、面向对象的五大基本原则
    1、单一职责原则: 类的功能要单一。只实现具体某一个功能, 不要将多个功能放在一个类中实现。
    2、开闭原则: 对扩展开发, 对修改封闭。
    3、里氏替换原则: 子类可以替换父类出现过的任何地方。子类 is a 父类。
    4、依赖倒置原则: 依赖抽象, 而不是以来具体实现。方便扩展, 提高复用性。
    5、接口隔离原则: 将接口进行拆分, 将多个功能拆分到多个接口中。每个接口实现一个功能。类似于单一职责原则。
7、接口与抽象类
    1、抽象类是定义子类共有通用的属性和方法, 表示子类 is a 父类。接口是定义子类具有哪些行为的, 表示子类 as a 父类。
    2、相同点:
        1、接口和抽象类本身不能实例化, 需要通过继承, 以子类来实例化使用。
        2、用于子类继承或实现。
        3、都包含抽象方法、子类继承或实现时, 必须重写。
    3、不同点:
        1、声明方式不同, 抽象类使用abstract, 接口使用interface。
        2、子类继承或实现的方式不同, 抽象类通过extends继承, 并且只能实现一个抽象类, 接口通过implements实现, 允许子类实现多个接口。
        3、抽象类可以有构造器, 接口不能有。
        4、抽象类中可以使用不同的访问修饰符, 而抽象类中属性都是public static final, 抽象方法都是public。
        5、Java8中接口, 引用了默认方法和静态方法。默认方法并不要求子类实现。
    4、如何选择
        1、行为模型应该优先使用接口而不是抽象类。
        2、当需要定义子类的通用行为时, 使用抽象类。
8、BIO、NIO、AIO
    1、BIO: Block IO 同步阻塞IO模式。数据的读取和写入必须阻塞在同一个线程内等待其完成。在活动连接数不是很高时(小于单机1000)的情况下, 可以让每个连接
    专注于自己的IO并且实现简单。也不用考虑系统的过载、限流等问题。可以使用线程池来缓存一些暂时处理不了的任务。但是当任务达到十万百万时, 传统的IO模式效率就非常低了。
    2、NIO: Non IO NIO是一种同步非阻塞IO模式。在jdk1.4中引入NIO。提供了Channel、Selector、Buffer等抽象。NIO中的N可以理解为Non-Blocking, 不单纯是new。
    它支持面向缓冲的, 基于通道的IO操作方式。NIO提供了与传统BIO模式中Socket、ServerSocket相对应的SocketChannel、ServerSocketChannel两种不同的套接字通道实现。
    两种通道都支持阻塞和非阻塞模式。阻塞模式就和BIO模式一样, 使用简单, 但性能和可靠性都不好。对于低负载、低并发的应用程序, 可以使用同步阻塞方式开发, 提高开发效率和维护性。
    对于高负载、高并发(网络)应用程序, 使用同步非阻塞模式来实现, 达到更好的并发性能。
    3、AIO: Asynchronous IO 在Java7中引入。它是异步非阻塞模式IO。基于事件和回调机制实现的。也就是调用方操作之后会立即返回, 线程不会阻塞, 当处理方处理完成后, 操作系统会
    通知相应线程进行后续操作。AIO是异步IO的缩写。虽然NIO在网络操作中, 提供了非阻塞的方法。但是NIO的行为还是同步的。对于NIO来说, 我们的业务线程是在IO操作准备好时(可以进行IO操作)
    得到通知, 接着就由这个线程自行进行IO操作, IO操作本身是同步的。
9、反射
    1、Java反射机制就是在运行状态中, 对于任意一个类, 都能获取其所有属性方法。对于任意一个对象, 都能调用其任意一个方法和属性。这种动态获取信息及动态调用对象方法的行为称为
    Java语言的反射机制。
    2、优缺点
        优点: 运行期类型判断, 动态加载类, 提高代码的灵活度, 方便扩展。
        缺点:
            性能问题, 需要通知JVM进行一系列的解释操作, 反射中包含了动态类型, JVM无法对这部分代码进行优化, 性能要比直接调用Java代码低。
            破获代码封装性。正常private修饰属性方法, 在类外部是不允许访问到的。使用反射会将内部暴露。
            对于有安全限制的系统环境中, 不能使用。
    3、应用场景
        1、反射是框架设计的灵魂
            JDBC连接数据库时, 使用Class.forName()加载数据库驱动。
            Spring装载Bean过程。
    4、实现反射的方式
        1、通过对象实例实现: Class clazz = object.getClass();
        2、通过类路径实现: Class clazz = Class.forName();
        3、通过类名实现: Class clazz = Object.class;
10、String真的是不可变的么?
    一般来说是的。一般开发中, 对String类型的变量做修改时, 都是将变量的引用改为其他地址。
    但是可以通过反射来修改String类中的char数组的值来实现改变String。
11、HashMap使用String做key的好处?
    HashMap保存数据时, 需要对key进行hash()处理, 获取key的散列码, 来确定其对应的存储位置。因为String是不可变的, 相同的字符串对应的散列码也不会改变。
    相同的字符串不需要重新计算散列值, 会被缓存下来, 方便下次使用, 所以会较其他对象更快。
12、Integer a = 127 和 Integer b = 128
    当整型在-128到127之间时, 不会创建其包装类, 会从常量池中获取。所以int a = 127 == Integer a = 127。当大于这个范围时, 会创建对应的包装类。此时==返回false。
    这个范围可以被修改-128到更大。
13、List、Set、Map
    1、List有序集合, 顺序为存入集合顺序。允许集合内元素重复, 可以插入多个null值。常用的List集合有ArrayList、LinkedList。
        1、实现方式
            1、ArrayList、Vector使用Object数组实现, 可以实现动态扩容。
            2、LinkedList使用双线链表实现。
    2、Set无序集合, 顺序与存入集合顺序不一致。不允许有重复元素, 只可以存入一个null值。常用Set集合有HashSet、TreeSet、LinkedHashSet。
        1、实现方式
            1、HashSet基于HashMap实现, 采用HashMap来保存元素。
            2、LinkedHashSet继承至HashSet, 内部基于LinkedHashSet实现。
            3、TreeSet红黑树实现。
    3、Map键值对集合。存储键值和二者的映射关系。key无序, 且唯一。value允许重复, 允许多个null值。通过key可以从集合中检索出对应value。
        1、实现方式
            1、HashMap在jdk1.8之前使用数组+链表实现。数组时HashMap的主体, 链表用来解决hash冲突。jdk1.8之后, 对解决hash冲突的链表进行改造, 当链表长度
            大于8时, 使用红黑树代替链表, 减少元素检索时间。
            2、LinkedHashMap继承至HashMap。
            3、HashTable数组+链表实现。数组是HashTable主体, 链表解决hash冲突。
            4、TreeMap使用红黑树实现。
14、什么是Java集合的快速失败机制fail-fast?
    1、fail-fast是Java集合的一种错误检测机制。当多个线程对集合进行结构上的并发修改的操作时, 会抛出ConcurrentModificationException, 从而会产生fail-fast机制。
    2、原因: 迭代器在遍历时直接访问集合中的内容, 并且在遍历过程中使用modCount变量, 记录集合结构上的修改操作次数, 每当迭代器获取下一个元素时, 都会检测modCount变量
    是否等于expectedModCount, 等于就继续遍历执行, 否则抛出异常, 终止遍历。
    3、解决方法:
        1、在多线程并发修改集合结构时, 增加锁, 对所有可能改变modCount值的地方都加上锁, 保证只有一个线程在改变集合。
        2、使用CopyOnWriteArrayList来代替ArrayList保证线程安全。
15、ArrayList和LinkedList的区别?
    1、数据结构与实现: ArrayList使用Object数组实现, 并且支持动态扩容。而LinkedList是使用双向链表实现。
    2、随机访问效率: ArrayList比LinkedList的效率高。ArrayList随机访问某个元素时, 只需使用下标即可定位到元素。而LinkedList随机访问某个元素时, 需要从第一个元素
    开始遍历, 直到目标元素。
    3、新增和删除效率: 在末尾增加元素时, 若ArrayList容量足够时, 二者效率几乎一样, 若ArrayList添加元素时需要扩容, 那么LinkedList效率较高。
    在非末尾处增加元素时, LinkedList效率较高, 因为ArrayList需要为后面的元素移动位置。
    4、内存空间占用: ArrayList占用空间较小。因为LinkedList使用的是双向链表实现, 每个节点除了存储元素数据外, 还要存储前后元素节点引用。
    5、线程安全: 二者都不是线程安全。
    6、在需要频繁读取集合元素时使用ArrayList。在频繁插入和删除时使用LinkedList。
16、ArrayList和Vector区别?
    1、性能: ArrayList较高。ArrayList不需要做同步操作, 非线程安全。效率更高。Vector线程安全。
    2、扩容: ArrayList每次扩容为原来的1.5倍。Vector扩容为原来的2倍。
17、为什么ArrayList的elementData加上transient修饰?
    ArrayList实现了Serializable接口, 表明ArrayList支持序列化。使用transient修饰elementData, 并且重写了writeObject序列化方法, 只序列化已经保存的元素,
    提高序列化速度, 减少序列化后的文件大小。
18、BlockingQueue 阻塞队列 用来实现生产者消费者
24、ConcurrentHashMap底层同步原理？
25、Class.forName()和classloader区别？
    classloader只是将.class文件加载到内存中, 而Class.forName()除了将.class加载到内存中, 还会执行类中static内容(可以设置是否执行)。
26、节点流和处理流
    1、节点流是可以从/向一个特定的IO设备读取/写入的数据流。成为节点流, 也称为低级流。接收具体设备。如 OutputStream、InputStream、Writer、Reader
    2、处理流是对一个已存在的流进行连接或封装, 通过封装后的流来实现读取/写入。也称为高级流。接受具体数据流。如BufferedInputStream等
27、Java注解
    1、元注解: @Target、@Retention、@Document、@Inherited
    2、自定义注解: 通过@interface创建自定义注解, 配合SpringAOP可以实现监控, 如劝权限控制、记录日志、统一异常处理等
28、Java内部类
    1、分类: 静态内部类, 匿名内部类, 成员内部类, 局部内部类
29、使用Java泛型
    泛型提供编译时安全检查机制, 可以在编译时检查出非法的类型。
    泛型的本质是类型参数化, 也就是说数据类型被指定成一个参数。
    实现原理: 类型擦除: 定义的泛型信息会在编译后被擦除, 在字节码文件中不会存在泛型信息。将泛型的地方使用具体类行代替, 如使用Object、父类。
30、Java浅拷贝与深拷贝
    1、浅拷贝: 只复制对象的引用不复制引用的对象。
    2、深拷贝: 复制对象的引用和引用的对象。
31、Java8 与 Java9
    1、Java9引入了模块系统(jdk被分为94个模块), 采用模块系统的应用程序只需要引入程序所需要的jdk部分, 而不是全部jdk框架, 减少内存开销。
    2、引入了新的包, java.net.http, 提供了Http1.1和HTTP2的支持。来代替之前的HttpURL Connection和Apache的Htt Client。据说性能很好。
    3、增加了集合工厂方法来创建不可变集合。
    4、垃圾收集机制Java 9移除了在Java 8中被废弃的垃圾回收器配置组合, 同时把G1设为默认的垃圾回收器实现.因为相对于Parallel来说，G1会在应用线程上做更多的事情,
    而Parallel几乎没有在应用线程上做任何事情, 它基本上完全依赖GC线程完成所有的内存管理。这意味着切换到G1将会为应用线程带来额外的工作，从而直接影响到应用的性能。
    5、IO流新特性java.io.InputStream中增加了新的方法来读取和复制InputStream 中包含的数据。readAllBytes:读取 InputStream中的所有剩余字节。
    readNBytes: 从 InputStream中读取指定数量的字节到数组中。transferTo:读取 InputStream 中的全部字节并写入到指定的OutputStream中。
31、Java8 特性
    1、接口增加默认方法: 在接口中定义一个非抽象的方法, 使用default修饰, 该方法子类可以不重写。
    2、Lambda表达式: 函数式接口
    3、新增Date Api, 如Clock时钟, LocalTime本地时间、LocalDate本地日期、LocalDateTime本地日期时间
    4、多重注解, 允许重复使用注解, 只需要在定义注解的时候使用@Repeatable标注
32、HashMap多线程并发操作时, 为什么会出现死循环?
    1、HashMap多线程并发访问, 并发调用get方法, 可能会造成死循环, 导致CPU使用率达到100%。
33、HashMap底层原理
    1、HashMap实现原理
        HashMap通过数组+链表实现, 存储K-V键值对。元素顺序与插入顺序不一致。HashMap基于hash算法实现, 每次添加元素时,
        根据key的hashCode来计算元素在数组中的位置。随着插入元素的增多, 元素的顺序会发生改变。
        当存储元素时, hashCode相同时, key如果也相同, 则覆盖原来数组中的元素, 若key不相同, 会将元素加入到数组对应的链表中。(jdk1.8之后)当链表元素个数超过8个时, 将链表转换成红黑树, 提高查询效率。
        当根据key获取元素时, 计算key的hashCode值, 在数组中找出相同hashCode值的元素, 判断key是否相同, 相同则直接去除数组中存储的value, 不相同则要遍历对应链表, 取值。
        在jdk1.8之后, 当数组扩容后, 移动原来元素至新数组中, 实现做了优化。jdk1.8前, 根据新数组重新计算元素位置(扰动函数(减少hash冲突方式)计算后key的hashCode % 数组长度)。
        jdk1.8后新位置等于原来位置或者原来位置+原来数组长度(数组容量扩容了2倍, 即对数组容量进行与运算计算新下标的时候, 新长度-1 的二进制多出一位1 这一位1就是原容量大小,
        如果元素hash值对应的这一位是1, 那么新位置就是原下标+原数组容量;如果元素hash值对应的这一位是0, 那么新位置就是原下标位置)。在源码中, 通过元素hash值 & 原容量(这里不减1,不是取模)
        如果结果为0, 元素未超过原容量, 则新位置就是原位置;如果结果不是0, 元素超过原容量, 则新位置就是原位置+原容量. 对比与jdk1.7, 不用对所有元素重新计算hash值,只使用简单的与运算进行判断,提高效率.
        每次扩容后容量为原来的2倍。初始化时最好设置为2的那次幂。HashMap确保容量为2的n次幂, 方便计算元素在数组中的下标(优化取模运算 n & (length - 1) 代替 n % length)。
    2、HashMap的put方法实现步骤
        1、判断键值是否为null, 为空则进行扩容。创建HashMap时不指定容量时, 键值数组为null。
        2、根据key计算的哈市Code得到对应插入数组位置, 如果该位置为null, 则直接插入。
        3、数组对应位置非null, 判断两个key是否相同(equals 及 hashCode都相同)。如果相同, 则直接覆盖value。
        4、判断数组中对应位置元素是否为红黑树节点, 是则代表该链表已经转成红黑树, 直接将该元素插入到红黑树中。
        5、若不是红黑树节点, 证明不存在链表, 或链表长度小于8, 还未转换成红黑树。
        6、遍历该链表, 如果插入该元素导致链表长度等于8, 那么将链表转成红黑树, 并且将元素插入到红黑树中(并不是所有链表长度大于8的时候都会转成红黑树,
        若容器中元素数量小于64的时候, 优先扩容, 当元素个数大于64时, 并且链表长度大于等于8时, 才会转换成红黑树)。
        若没有则将该元素插入到链表的对应位置(不存在相同的key放在链表末尾, 存在相同的key直接覆盖对应的value值)。
        7、插入成功后, 判断当前HashMap元素个数是否已经到达扩容值(threshold, 即元素个数*负载因子)。相等就扩容。
    3、HashMap如何实现扩容操作?
        1、jdk1.8中, 初始化或当元素个数大于阙值(容量 * 复杂因子0.75)时, 调用resize()方法进行扩容。每次扩容至原来容量的2倍(初始化扩容容量为16)。扩容后, 元素所在位置, 要么在原来的位置, 要么在
        原来2倍索引位置;而jdk1.7中, 扩容后需要重新计算key的hash值, 确定扩容后元素的位置。
    4、HashMap如何解决哈希冲突
        1、使用数组和链表结合的方式存储元素。将具有相同哈希值的元素存储在一个链表下。
        2、在获取哈希值的时候, 使用扰动函数(jdk1.8中hash值的高位与低位进行与运算), 处理key值, 降低哈希冲突概率。
        3、引入红黑树处理链表, 加快链表查询速度。
    5、能否使用任何类型作为HashMap的key
        1、自定义类是否重写了equals和hashcode方法, 如没有重写在put时, 可能导致数据问题。
        使用Object的equals方法判断, 两个相同的key, 需要进行是否相同的判断, 没有重写会被判断成两个不相同的值, 使HashMap存储了两个重复的键值对。
        2、在使用自定义类型时, 最好保证key类不可变。方便将HashCode缓存起来, 提高性能。
    6、HashMap中的“死锁”是怎么回事？
    7、HashMap中能put两个相同key吗？为什么？
        在put元素时, 会对key计算hash值, 如过存在相同的key, 那么会用新值覆盖旧值。
    8、HashMap中的键值可以为null吗？原理？
        在HashMap中允许存入null键, 但只允许一个, null值可以有多个。并且null键, 会永远被放在第一个。以为在计算hash值时, 规定null的索引下标为0, 即数组的第一个位置。
        之后null键对应的Entry会覆盖数组的第一个位置。(问题：有没有一个key值, 其hash计算结果=0, 被放在数组下标第一个位置。那么后续的key==null的如何存放。)
    9、HashMap扩容机制？
        HashMap通过resize方法扩容为原来容量的两倍, 并且将原来容器中元素移动到新容器中。
        jdk1.7中对原容器中所有元素重新计算确定在新容器中的位置, 对于链表, 使用头插法(如果出现冲突)将链表依次插入到新容器中。对于key更具新数组容量重新计算下标,
        将这个key对应的Entry放到新数组的下标对应的位置, 并且如果新数组下标原来有元素, 将这些元素链接到该节点之后(头插法)。
        jdk1.8中原来元素在新容器的位置, 为原来位置或原来位置+原容器大小。
    10、为什么链表长度大于等于8才会转成红黑树? 为什么链表长度小于等于6会转成链表?
        转换成红黑树时, 虽然可以提升元素检索速度, 但是因为红黑树节点大约是普通节点的两倍。转换过程即耗时又耗内存, 所以要规定临界值什么时候转成红黑树,
        什么时候准换成链表。这个值不能太大, 会影响元素检索速度, 如果这个值太小, 就会频繁的转换红黑树, 浪费资源。
        链表长度也就表示添加到容器总的元素出现在同一个位置的概率。经过计算当链表长度为8, 那么之后的概率不足千万分之一, 所以选择8作为转换链表的条件。
    11、HashMap如何保证索引都在2^30之内?
        在put元素时, 会对元素的hash值, 对数组容量进行取模运算(使用位运算代替, 提高效率), 元素一定会在容量范围内。
    12、HashMap为什么元素个数小于64优先扩容
        效率问题, 当元素个数小于64时, 选择扩容, 将数组容量扩大, 将元素更加分散的加入到数组中, 数组容量小的时候更容易产生哈希冲突。
34、Java中string长度限制。其他类型长度限制。
35、ConcurrentHashMap实现原理。
    jdk1.7中ConCurrentHashMap采用分段式锁的机制, 实现并发的更新操作。底层采用数组+链表的存储结构。其核心是两个静态内部类Segment和HashEntry.
        Segment集成了ReentrantLock充当锁, 每个Segment对象守护每个散列映射表的若干桶。
        HashEntry用来封装映射表的键值对。
        每个桶由若干个HashEntry对象链接起来的链表。
    jdk1.8中已经放弃了Segment, 使用CAS+synchronized来保证并发更新的安全。底层采用数组+链表+红黑树的存储结构。
    为什么不允许key为null?
36、Java内存模型
37、Java中的Unsafe
38、Java中的CAS
39、Java同步器
40、ReentrantLock
41、对象头 对象存储结构
42、局部变量生命周期，生命周期结束后GC何时清理。
43、基础类型存在哪里
44、Java四种引用

